[
  {
    "name": "Astoriod_0",
    "index": 0,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 3,
    "color": [
      111,
      31,
      25
    ],
    "texture_index": 4,
    "size": 8.851360230813196,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "ACD8622F-A2D3-4921-A679-6F77C7242701",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "8E8C521C-B4B3-433B-940E-98B27DEE3A3B"
        },
        "color": {
          "type": "c",
          "value": 1854929383
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_1",
    "index": 1,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 3,
    "color": [
      111,
      31,
      25
    ],
    "texture_index": 2,
    "size": 10.695938341977826,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "83FEDE60-35B1-40D5-A9AA-85CDCE7F02D0",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "23BF5BAF-E8E3-4DE3-ADB8-9BCB64DD3F13"
        },
        "color": {
          "type": "c",
          "value": 1854929383
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_2",
    "index": 2,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 0,
    "color": [
      191,
      239,
      255
    ],
    "texture_index": 4,
    "size": 6.270433557863436,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "DBDCC1D9-0BA1-4042-824D-0B90E69F5A51",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "8E8C521C-B4B3-433B-940E-98B27DEE3A3B"
        },
        "color": {
          "type": "c",
          "value": -1095766271
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_3",
    "index": 3,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 2,
    "color": [
      246,
      163,
      163
    ],
    "texture_index": 1,
    "size": 4.386321623230545,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "99DA293E-8D32-40F6-8059-B23E608D771E",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9D3DC8C1-9F1A-4CC0-9457-FACC3A37BDAD"
        },
        "color": {
          "type": "c",
          "value": -173473955
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_4",
    "index": 4,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 2,
    "color": [
      246,
      163,
      163
    ],
    "texture_index": 1,
    "size": 6.865913367920667,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "4BE9659A-3C4A-4332-83F5-E8F96369CB1A",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9D3DC8C1-9F1A-4CC0-9457-FACC3A37BDAD"
        },
        "color": {
          "type": "c",
          "value": -173473955
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_5",
    "index": 5,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 3,
    "color": [
      111,
      31,
      25
    ],
    "texture_index": 2,
    "size": 10.209296064078213,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "050C5A47-D477-47A0-8484-AE5840DD025A",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "23BF5BAF-E8E3-4DE3-ADB8-9BCB64DD3F13"
        },
        "color": {
          "type": "c",
          "value": 1854929383
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_6",
    "index": 6,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 3,
    "color": [
      111,
      31,
      25
    ],
    "texture_index": 2,
    "size": 10.738821657699733,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "2272C503-D39F-4F6C-9990-388447DAC4F3",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "23BF5BAF-E8E3-4DE3-ADB8-9BCB64DD3F13"
        },
        "color": {
          "type": "c",
          "value": 1854929383
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_7",
    "index": 7,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 2,
    "color": [
      246,
      163,
      163
    ],
    "texture_index": 1,
    "size": 8.403729097217973,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "5D4F51BB-C130-4773-86C1-8AFA9E41E4BA",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9D3DC8C1-9F1A-4CC0-9457-FACC3A37BDAD"
        },
        "color": {
          "type": "c",
          "value": -173473955
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_8",
    "index": 8,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 1,
    "color": [
      195,
      150,
      121
    ],
    "texture_index": 0,
    "size": 6.742804031133675,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "54D0DB8B-03E6-4C35-A24D-C17F6EBDBC92",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "F557E4BD-900F-4405-A9EF-223B055EA02F"
        },
        "color": {
          "type": "c",
          "value": -1029172601
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_9",
    "index": 9,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 2,
    "color": [
      246,
      163,
      163
    ],
    "texture_index": 4,
    "size": 5.458502593211799,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "7D6FB3E8-BE4A-4DAF-B5E7-C964DA3C4D85",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "8E8C521C-B4B3-433B-940E-98B27DEE3A3B"
        },
        "color": {
          "type": "c",
          "value": -173473955
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_10",
    "index": 10,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 1,
    "color": [
      195,
      150,
      121
    ],
    "texture_index": 2,
    "size": 10.895365913485913,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "24312D6C-2F91-47B3-94BC-A5C34F4368ED",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "23BF5BAF-E8E3-4DE3-ADB8-9BCB64DD3F13"
        },
        "color": {
          "type": "c",
          "value": -1029172601
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_11",
    "index": 11,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 1,
    "color": [
      195,
      150,
      121
    ],
    "texture_index": 2,
    "size": 8.031058615268552,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "E9D02EBD-7028-422C-99A1-6722A8DB5804",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "23BF5BAF-E8E3-4DE3-ADB8-9BCB64DD3F13"
        },
        "color": {
          "type": "c",
          "value": -1029172601
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_12",
    "index": 12,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 0,
    "color": [
      191,
      239,
      255
    ],
    "texture_index": 4,
    "size": 5.998007138305855,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "B8F06BB2-5337-4FCF-9D15-6B4F3AF59A63",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "8E8C521C-B4B3-433B-940E-98B27DEE3A3B"
        },
        "color": {
          "type": "c",
          "value": -1095766271
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_13",
    "index": 13,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 0,
    "color": [
      191,
      239,
      255
    ],
    "texture_index": 0,
    "size": 4.886813113965092,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "D2886278-C95C-4808-AE14-F466385C627F",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "F557E4BD-900F-4405-A9EF-223B055EA02F"
        },
        "color": {
          "type": "c",
          "value": -1095766271
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_14",
    "index": 14,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 4,
    "color": [
      74,
      112,
      139
    ],
    "texture_index": 2,
    "size": 11.059082273489203,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "B3978846-5186-4FC7-AAA6-1DD9A66193EB",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "23BF5BAF-E8E3-4DE3-ADB8-9BCB64DD3F13"
        },
        "color": {
          "type": "c",
          "value": 1238964853
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_15",
    "index": 15,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 0,
    "color": [
      191,
      239,
      255
    ],
    "texture_index": 1,
    "size": 4.404529069275696,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "BD68056C-5EF1-44F0-A1FA-AE78278B0DFE",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9D3DC8C1-9F1A-4CC0-9457-FACC3A37BDAD"
        },
        "color": {
          "type": "c",
          "value": -1095766271
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_16",
    "index": 16,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 3,
    "color": [
      111,
      31,
      25
    ],
    "texture_index": 4,
    "size": 6.656500726517621,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "6CA32B3C-0BF6-4870-8EC4-21C49739F09C",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "8E8C521C-B4B3-433B-940E-98B27DEE3A3B"
        },
        "color": {
          "type": "c",
          "value": 1854929383
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_17",
    "index": 17,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 1,
    "color": [
      195,
      150,
      121
    ],
    "texture_index": 1,
    "size": 5.964120975877368,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "E37BDFC2-A72B-4FC1-B2BB-4A06E40DBC56",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9D3DC8C1-9F1A-4CC0-9457-FACC3A37BDAD"
        },
        "color": {
          "type": "c",
          "value": -1029172601
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_18",
    "index": 18,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 0,
    "color": [
      191,
      239,
      255
    ],
    "texture_index": 2,
    "size": 10.183963183002747,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "14B12AF1-2CE5-482E-BEDE-121BEA73ECB5",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "23BF5BAF-E8E3-4DE3-ADB8-9BCB64DD3F13"
        },
        "color": {
          "type": "c",
          "value": -1095766271
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_19",
    "index": 19,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 3,
    "color": [
      111,
      31,
      25
    ],
    "texture_index": 4,
    "size": 10.588510781133524,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "2A4BF543-6D9C-43CF-899B-BA00003A7031",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "8E8C521C-B4B3-433B-940E-98B27DEE3A3B"
        },
        "color": {
          "type": "c",
          "value": 1854929383
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_20",
    "index": 20,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 3,
    "color": [
      111,
      31,
      25
    ],
    "texture_index": 1,
    "size": 11.76635446548638,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "7F863927-9CDF-4EE3-80D5-B49B7FE768F7",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9D3DC8C1-9F1A-4CC0-9457-FACC3A37BDAD"
        },
        "color": {
          "type": "c",
          "value": 1854929383
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_21",
    "index": 21,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 3,
    "color": [
      111,
      31,
      25
    ],
    "texture_index": 3,
    "size": 5.428429550941296,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "9A29BD63-1833-4E0B-ACA8-072171EF1063",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9B7D2D11-760D-47BC-85A2-EBE240E7D4C3"
        },
        "color": {
          "type": "c",
          "value": 1854929383
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_22",
    "index": 22,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 1,
    "color": [
      195,
      150,
      121
    ],
    "texture_index": 2,
    "size": 5.776619006868069,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "772B8F9F-E158-42E7-B106-8DBF167E2FCA",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "23BF5BAF-E8E3-4DE3-ADB8-9BCB64DD3F13"
        },
        "color": {
          "type": "c",
          "value": -1029172601
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_23",
    "index": 23,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 3,
    "color": [
      111,
      31,
      25
    ],
    "texture_index": 2,
    "size": 11.320394878334032,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "84C26BE7-B5DE-4F80-BD19-F8D756B11CEA",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "23BF5BAF-E8E3-4DE3-ADB8-9BCB64DD3F13"
        },
        "color": {
          "type": "c",
          "value": 1854929383
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_24",
    "index": 24,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 1,
    "color": [
      195,
      150,
      121
    ],
    "texture_index": 1,
    "size": 9.272135565452981,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "64EEDB41-ECC6-4878-8CA6-731C59609C74",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9D3DC8C1-9F1A-4CC0-9457-FACC3A37BDAD"
        },
        "color": {
          "type": "c",
          "value": -1029172601
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_25",
    "index": 25,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 2,
    "color": [
      246,
      163,
      163
    ],
    "texture_index": 1,
    "size": 9.582067683750465,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "EBA681E1-08E0-4947-B843-721B13E827DA",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9D3DC8C1-9F1A-4CC0-9457-FACC3A37BDAD"
        },
        "color": {
          "type": "c",
          "value": -173473955
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_26",
    "index": 26,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 1,
    "color": [
      195,
      150,
      121
    ],
    "texture_index": 1,
    "size": 7.431994993380551,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "C2529C54-23C5-41BD-AFAE-9EB25DC3601E",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9D3DC8C1-9F1A-4CC0-9457-FACC3A37BDAD"
        },
        "color": {
          "type": "c",
          "value": -1029172601
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_27",
    "index": 27,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 3,
    "color": [
      111,
      31,
      25
    ],
    "texture_index": 2,
    "size": 11.973609643240383,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "8BFDE319-9BB7-4088-88E3-9CCE88D6E388",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "23BF5BAF-E8E3-4DE3-ADB8-9BCB64DD3F13"
        },
        "color": {
          "type": "c",
          "value": 1854929383
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_28",
    "index": 28,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 3,
    "color": [
      111,
      31,
      25
    ],
    "texture_index": 2,
    "size": 7.343900245934826,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "5D436232-7BFD-4DAE-8D56-1679E28FC3FD",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "23BF5BAF-E8E3-4DE3-ADB8-9BCB64DD3F13"
        },
        "color": {
          "type": "c",
          "value": 1854929383
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_29",
    "index": 29,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 3,
    "color": [
      111,
      31,
      25
    ],
    "texture_index": 3,
    "size": 9.726859491908824,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "50614E52-0791-4D21-A771-033BC4BA7043",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9B7D2D11-760D-47BC-85A2-EBE240E7D4C3"
        },
        "color": {
          "type": "c",
          "value": 1854929383
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_30",
    "index": 30,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 0,
    "color": [
      191,
      239,
      255
    ],
    "texture_index": 1,
    "size": 10.80202229711873,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "95FABB73-BC71-4A88-84DC-5037F26A1926",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9D3DC8C1-9F1A-4CC0-9457-FACC3A37BDAD"
        },
        "color": {
          "type": "c",
          "value": -1095766271
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_31",
    "index": 31,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 3,
    "color": [
      111,
      31,
      25
    ],
    "texture_index": 2,
    "size": 6.485501220235296,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "225D46F1-4408-4CFD-8C68-E0AE3159E89F",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "23BF5BAF-E8E3-4DE3-ADB8-9BCB64DD3F13"
        },
        "color": {
          "type": "c",
          "value": 1854929383
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_32",
    "index": 32,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 3,
    "color": [
      111,
      31,
      25
    ],
    "texture_index": 2,
    "size": 8.272536860819514,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "993245AA-6495-449D-895D-E79EA83E1359",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "23BF5BAF-E8E3-4DE3-ADB8-9BCB64DD3F13"
        },
        "color": {
          "type": "c",
          "value": 1854929383
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_33",
    "index": 33,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 0,
    "color": [
      191,
      239,
      255
    ],
    "texture_index": 3,
    "size": 5.242578345055994,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "DC975C6E-E440-41C0-855F-DD7C5DEFD10A",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9B7D2D11-760D-47BC-85A2-EBE240E7D4C3"
        },
        "color": {
          "type": "c",
          "value": -1095766271
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_34",
    "index": 34,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 1,
    "color": [
      195,
      150,
      121
    ],
    "texture_index": 1,
    "size": 6.013550629210595,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "8DE3BCC1-B51B-4D99-8B6B-EA2A6216CB58",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9D3DC8C1-9F1A-4CC0-9457-FACC3A37BDAD"
        },
        "color": {
          "type": "c",
          "value": -1029172601
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_35",
    "index": 35,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 1,
    "color": [
      195,
      150,
      121
    ],
    "texture_index": 2,
    "size": 8.717300324968063,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "05EF4042-EB1F-492B-80C2-0EA6AAFF60C9",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "23BF5BAF-E8E3-4DE3-ADB8-9BCB64DD3F13"
        },
        "color": {
          "type": "c",
          "value": -1029172601
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_36",
    "index": 36,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 2,
    "color": [
      246,
      163,
      163
    ],
    "texture_index": 1,
    "size": 9.034587038430997,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "6B651A7F-699B-4749-97CB-A45CF7614B0C",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9D3DC8C1-9F1A-4CC0-9457-FACC3A37BDAD"
        },
        "color": {
          "type": "c",
          "value": -173473955
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_37",
    "index": 37,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 2,
    "color": [
      246,
      163,
      163
    ],
    "texture_index": 0,
    "size": 7.2571203726129525,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "89F8ACAD-3D41-4AE6-938B-6204A9E23BCB",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "F557E4BD-900F-4405-A9EF-223B055EA02F"
        },
        "color": {
          "type": "c",
          "value": -173473955
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_38",
    "index": 38,
    "colorPalleteIndex": 5,
    "colorArrayIndex": 3,
    "color": [
      111,
      31,
      25
    ],
    "texture_index": 0,
    "size": 6.100882826466442,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "93C7F778-8531-4A09-B4A7-C48A8A626A33",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "F557E4BD-900F-4405-A9EF-223B055EA02F"
        },
        "color": {
          "type": "c",
          "value": 1854929383
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -446.759211189051,
            90.50744353088368,
            205.46194266394156
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  }
]