[
  {
    "name": "Astoriod_0",
    "index": 0,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 4,
    "color": [
      46,
      132,
      206
    ],
    "texture_index": 2,
    "size": 7.526695346673863,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "F721C6FB-4777-43B4-80AE-9BD36544740E",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": 760328498
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_1",
    "index": 1,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 4,
    "color": [
      46,
      132,
      206
    ],
    "texture_index": 3,
    "size": 11.326365554108161,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "D1A6783F-5315-4D81-9771-BA48F6A4244C",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A4BA980C-F28A-4B96-B9FF-98891244A608"
        },
        "color": {
          "type": "c",
          "value": 760328498
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_2",
    "index": 2,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 2,
    "color": [
      98,
      174,
      231
    ],
    "texture_index": 2,
    "size": 4.011786864313239,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "65A08299-1C27-47D3-8A3C-81F60C93169E",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": 1630778393
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_3",
    "index": 3,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 2,
    "color": [
      98,
      174,
      231
    ],
    "texture_index": 2,
    "size": 10.13665514545385,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "B2A81306-DE5F-45C3-B0C1-50B776B840AC",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": 1630778393
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_4",
    "index": 4,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 5,
    "color": [
      175,
      219,
      245
    ],
    "texture_index": 2,
    "size": 8.070615407447276,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "F52A1DC6-5A8A-4F38-9FFC-9BA4E539C370",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": -1366568693
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_5",
    "index": 5,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 2,
    "color": [
      98,
      174,
      231
    ],
    "texture_index": 3,
    "size": 7.325078456175238,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "BDE4E8E5-4A92-4AB4-970E-34B8305EE416",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A4BA980C-F28A-4B96-B9FF-98891244A608"
        },
        "color": {
          "type": "c",
          "value": 1630778393
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_6",
    "index": 6,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 2,
    "color": [
      98,
      174,
      231
    ],
    "texture_index": 3,
    "size": 9.371175224682538,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "628DA60A-D446-4B6F-B56B-20C1D5DF4969",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A4BA980C-F28A-4B96-B9FF-98891244A608"
        },
        "color": {
          "type": "c",
          "value": 1630778393
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_7",
    "index": 7,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 2,
    "color": [
      98,
      174,
      231
    ],
    "texture_index": 3,
    "size": 11.32218777514862,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "AE2677E7-C0DF-4276-9C3A-C91F0B9203E5",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A4BA980C-F28A-4B96-B9FF-98891244A608"
        },
        "color": {
          "type": "c",
          "value": 1630778393
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_8",
    "index": 8,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 4,
    "color": [
      46,
      132,
      206
    ],
    "texture_index": 3,
    "size": 9.475270163612372,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "25AB4E70-9C31-4AEB-94AC-59EC1F5BCD4D",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A4BA980C-F28A-4B96-B9FF-98891244A608"
        },
        "color": {
          "type": "c",
          "value": 760328498
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_9",
    "index": 9,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 3,
    "color": [
      66,
      150,
      220
    ],
    "texture_index": 3,
    "size": 11.875088974821947,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "5BB4AAA2-488A-474C-ADF5-B9A4A96050C0",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A4BA980C-F28A-4B96-B9FF-98891244A608"
        },
        "color": {
          "type": "c",
          "value": 1093382436
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_10",
    "index": 10,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 4,
    "color": [
      46,
      132,
      206
    ],
    "texture_index": 0,
    "size": 7.919886897697902,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "72020030-B21C-4A51-AD4E-9C40C4F2038E",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "54F4BBE7-D0F0-44AE-967A-74D3E830C1BC"
        },
        "color": {
          "type": "c",
          "value": 760328498
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_11",
    "index": 11,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 6,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 0,
    "size": 11.82697069917726,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "61008A01-01A6-471C-ADC8-1121211C7C20",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "54F4BBE7-D0F0-44AE-967A-74D3E830C1BC"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_12",
    "index": 12,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 3,
    "color": [
      66,
      150,
      220
    ],
    "texture_index": 4,
    "size": 7.052212127959049,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "B8750488-DFE0-497F-9DF9-3813881FACD3",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "E30BDF75-7A06-462B-A66B-62A9EF9DA07A"
        },
        "color": {
          "type": "c",
          "value": 1093382436
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_13",
    "index": 13,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 7,
    "color": [
      98,
      174,
      231
    ],
    "texture_index": 2,
    "size": 7.787942644994091,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "95ABD0B8-78D8-4CF4-898D-8F5F844ACB2B",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": 1630778393
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_14",
    "index": 14,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 3,
    "color": [
      66,
      150,
      220
    ],
    "texture_index": 0,
    "size": 7.271857355133205,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "F3F67A99-0476-4638-B876-16D711989D86",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "54F4BBE7-D0F0-44AE-967A-74D3E830C1BC"
        },
        "color": {
          "type": "c",
          "value": 1093382436
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_15",
    "index": 15,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 1,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 2,
    "size": 4.4676312320404605,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "A0EB3895-D104-4310-81E3-14969590B2CD",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_16",
    "index": 16,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 3,
    "color": [
      66,
      150,
      220
    ],
    "texture_index": 0,
    "size": 7.653347817370561,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "7C0F7CB6-AB14-48DF-9C0A-197E1040D09A",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "54F4BBE7-D0F0-44AE-967A-74D3E830C1BC"
        },
        "color": {
          "type": "c",
          "value": 1093382436
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_17",
    "index": 17,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 0,
    "color": [
      175,
      219,
      245
    ],
    "texture_index": 1,
    "size": 4.169709533603477,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "6ECE8DA2-A9EE-410E-B7D6-9D1799B63ED4",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": -1366568693
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_18",
    "index": 18,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 7,
    "color": [
      98,
      174,
      231
    ],
    "texture_index": 2,
    "size": 10.283873660419495,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "6B55294E-FDA8-4535-B1BC-346CEEB5AD30",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": 1630778393
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_19",
    "index": 19,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 5,
    "color": [
      175,
      219,
      245
    ],
    "texture_index": 0,
    "size": 11.355946165821562,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "BB8C9603-2A78-4248-B18E-1B5D3304B0B4",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "54F4BBE7-D0F0-44AE-967A-74D3E830C1BC"
        },
        "color": {
          "type": "c",
          "value": -1366568693
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_20",
    "index": 20,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 3,
    "color": [
      66,
      150,
      220
    ],
    "texture_index": 3,
    "size": 8.733996067759978,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "2AAB2538-99B1-467A-A9F4-4ED597E1164B",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A4BA980C-F28A-4B96-B9FF-98891244A608"
        },
        "color": {
          "type": "c",
          "value": 1093382436
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_21",
    "index": 21,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 3,
    "color": [
      66,
      150,
      220
    ],
    "texture_index": 4,
    "size": 8.248966432141545,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "BB73208F-48EA-45D9-87D3-2ED435A6CD1D",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "E30BDF75-7A06-462B-A66B-62A9EF9DA07A"
        },
        "color": {
          "type": "c",
          "value": 1093382436
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_22",
    "index": 22,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 2,
    "color": [
      98,
      174,
      231
    ],
    "texture_index": 0,
    "size": 5.206136650680023,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "BC3C51A6-2DC2-40B2-9C63-01FDD6F9172F",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "54F4BBE7-D0F0-44AE-967A-74D3E830C1BC"
        },
        "color": {
          "type": "c",
          "value": 1630778393
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_23",
    "index": 23,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 7,
    "color": [
      98,
      174,
      231
    ],
    "texture_index": 2,
    "size": 10.088963072724809,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "AF2DD8B5-C446-4F11-B390-D422B1F5EEF9",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": 1630778393
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_24",
    "index": 24,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 6,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 3,
    "size": 7.961794321392832,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "2381E077-BA9C-423D-B998-1225916F190D",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A4BA980C-F28A-4B96-B9FF-98891244A608"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_25",
    "index": 25,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 4,
    "color": [
      46,
      132,
      206
    ],
    "texture_index": 4,
    "size": 4.222183090247123,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "D901B7C2-447D-4B1B-9F84-1304E1468660",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "E30BDF75-7A06-462B-A66B-62A9EF9DA07A"
        },
        "color": {
          "type": "c",
          "value": 760328498
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_26",
    "index": 26,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 5,
    "color": [
      175,
      219,
      245
    ],
    "texture_index": 2,
    "size": 6.998266912949948,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "D5D6232C-6D8E-4C3E-A83E-F376C88E64DF",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": -1366568693
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_27",
    "index": 27,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 1,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 2,
    "size": 9.419385125141789,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "F1569F56-8463-4D08-8A52-ED7B2FB0098A",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_28",
    "index": 28,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 7,
    "color": [
      98,
      174,
      231
    ],
    "texture_index": 4,
    "size": 11.82481427055934,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "3D5B6F72-0B09-400F-9274-6285AE51139F",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "E30BDF75-7A06-462B-A66B-62A9EF9DA07A"
        },
        "color": {
          "type": "c",
          "value": 1630778393
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_29",
    "index": 29,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 0,
    "color": [
      175,
      219,
      245
    ],
    "texture_index": 2,
    "size": 10.266329579597134,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "3A8E24A4-93A4-484C-8A96-03EFE2234CD2",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": -1366568693
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_30",
    "index": 30,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 3,
    "color": [
      66,
      150,
      220
    ],
    "texture_index": 2,
    "size": 9.03007973902734,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "E062D087-907C-4158-89CF-0AB2531C4972",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": 1093382436
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_31",
    "index": 31,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 1,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 1,
    "size": 5.122793668680785,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "B01BE7C0-C80B-4C37-9961-3CDB44B892C5",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_32",
    "index": 32,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 5,
    "color": [
      175,
      219,
      245
    ],
    "texture_index": 1,
    "size": 8.354324176753456,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "2413C1D6-CEA8-4579-B6E0-0F61DF7F453D",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": -1366568693
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_33",
    "index": 33,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 3,
    "color": [
      66,
      150,
      220
    ],
    "texture_index": 0,
    "size": 5.0981288398421825,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "BADA5A17-F379-4E98-BFE4-BBE22E293C6F",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "54F4BBE7-D0F0-44AE-967A-74D3E830C1BC"
        },
        "color": {
          "type": "c",
          "value": 1093382436
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_34",
    "index": 34,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 5,
    "color": [
      175,
      219,
      245
    ],
    "texture_index": 1,
    "size": 4.932535057593567,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "3D17BECF-6F6E-41D9-AA1C-B4BC22F685B0",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": -1366568693
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_35",
    "index": 35,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 6,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 3,
    "size": 6.242555643853821,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "1A7E972F-B926-4D39-A0DF-65B6EEE21776",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A4BA980C-F28A-4B96-B9FF-98891244A608"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_36",
    "index": 36,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 6,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 2,
    "size": 11.419415435228393,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "514B4B58-B7F8-431E-852B-92449B8730F3",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_37",
    "index": 37,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 0,
    "color": [
      175,
      219,
      245
    ],
    "texture_index": 2,
    "size": 9.349926889172949,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "B49C7522-C10C-487B-81CA-C23ECD79A6D6",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": -1366568693
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_38",
    "index": 38,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 2,
    "color": [
      98,
      174,
      231
    ],
    "texture_index": 3,
    "size": 7.301121344262388,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "C9B9FB7F-560D-4A82-B0A3-EF5E16EF2794",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A4BA980C-F28A-4B96-B9FF-98891244A608"
        },
        "color": {
          "type": "c",
          "value": 1630778393
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_39",
    "index": 39,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 4,
    "color": [
      46,
      132,
      206
    ],
    "texture_index": 2,
    "size": 9.457558051685144,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "2B7AB508-8F7F-45B8-8C23-5EBB3820FD58",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": 760328498
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_40",
    "index": 40,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 3,
    "color": [
      66,
      150,
      220
    ],
    "texture_index": 0,
    "size": 6.324008749516553,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "37ABA4D1-771D-4295-B87F-2A81EF64A873",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "54F4BBE7-D0F0-44AE-967A-74D3E830C1BC"
        },
        "color": {
          "type": "c",
          "value": 1093382436
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_41",
    "index": 41,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 3,
    "color": [
      66,
      150,
      220
    ],
    "texture_index": 1,
    "size": 8.325094918526807,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "DD96D4B9-599F-430A-94DE-351BF8FE4A8C",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": 1093382436
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_42",
    "index": 42,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 6,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 0,
    "size": 10.222810211274291,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "F10CCE38-E5A8-4EFE-BBC4-B307B4AD2AD9",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "54F4BBE7-D0F0-44AE-967A-74D3E830C1BC"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_43",
    "index": 43,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 2,
    "color": [
      98,
      174,
      231
    ],
    "texture_index": 0,
    "size": 11.565921334711287,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "3C2F149C-2A49-4CB0-9EC0-9465EBFC0A28",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "54F4BBE7-D0F0-44AE-967A-74D3E830C1BC"
        },
        "color": {
          "type": "c",
          "value": 1630778393
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_44",
    "index": 44,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 5,
    "color": [
      175,
      219,
      245
    ],
    "texture_index": 3,
    "size": 6.220586825046549,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "B30B40F8-1671-4F8A-BFCB-B5724A6CA8CF",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A4BA980C-F28A-4B96-B9FF-98891244A608"
        },
        "color": {
          "type": "c",
          "value": -1366568693
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_45",
    "index": 45,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 1,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 1,
    "size": 5.6630592345273705,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "40C28670-4ADB-43BB-8917-B50CC3D6D0EE",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_46",
    "index": 46,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 1,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 0,
    "size": 6.645547316594978,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "0418590E-2AC7-4C8C-B700-F52927714BCA",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "54F4BBE7-D0F0-44AE-967A-74D3E830C1BC"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_47",
    "index": 47,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 6,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 1,
    "size": 6.547365054443032,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "48351333-E2C4-4DDB-8522-7DF5BFCA46BD",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_48",
    "index": 48,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 1,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 2,
    "size": 7.478240162423919,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "2400722D-84CA-42AC-A188-702474848135",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_49",
    "index": 49,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 3,
    "color": [
      66,
      150,
      220
    ],
    "texture_index": 1,
    "size": 11.518764041039777,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "70FF65C6-13C2-4B0D-BE86-F1E6ED1A8553",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": 1093382436
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_50",
    "index": 50,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 5,
    "color": [
      175,
      219,
      245
    ],
    "texture_index": 1,
    "size": 6.23989774085571,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "8DDD7B3C-2E95-42E5-BEE7-CD089DE7026F",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": -1366568693
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  }
]