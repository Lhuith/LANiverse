[
  {
    "name": "Astoriod_0",
    "index": 0,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 3,
    "color": [
      66,
      150,
      220
    ],
    "texture_index": 1,
    "size": 10.641671161855877,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "D6AA6E96-C65C-4787-B437-2DC744730560",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": 1093382436
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_1",
    "index": 1,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 5,
    "color": [
      175,
      219,
      245
    ],
    "texture_index": 0,
    "size": 10.921474585285347,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "EDFE0615-BDC3-4251-91A3-DFEE3131553A",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "54F4BBE7-D0F0-44AE-967A-74D3E830C1BC"
        },
        "color": {
          "type": "c",
          "value": -1366568693
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_2",
    "index": 2,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 7,
    "color": [
      98,
      174,
      231
    ],
    "texture_index": 2,
    "size": 7.392116524639578,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "025F0913-1EFB-4062-9A8A-8ADA3779F614",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": 1630778393
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_3",
    "index": 3,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 4,
    "color": [
      46,
      132,
      206
    ],
    "texture_index": 1,
    "size": 4.183698075735727,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "3494BF93-43C5-4693-B5E4-9875E90E3A6E",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": 760328498
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_4",
    "index": 4,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 3,
    "color": [
      66,
      150,
      220
    ],
    "texture_index": 2,
    "size": 4.571761792577522,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "BBB35241-67A5-4B9F-A685-3F4E2DB7AC77",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": 1093382436
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_5",
    "index": 5,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 5,
    "color": [
      175,
      219,
      245
    ],
    "texture_index": 3,
    "size": 8.267108031225073,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "8A87C9BA-E30A-4B9F-AAEB-BED10FEDFEAB",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A4BA980C-F28A-4B96-B9FF-98891244A608"
        },
        "color": {
          "type": "c",
          "value": -1366568693
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_6",
    "index": 6,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 6,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 1,
    "size": 11.36065921312236,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "F6615885-3382-43CF-A46B-0B19CE5DA530",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_7",
    "index": 7,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 1,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 2,
    "size": 8.309779865750109,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "8CBA6FD9-B36E-470A-8210-77F2D7A39540",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_8",
    "index": 8,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 3,
    "color": [
      66,
      150,
      220
    ],
    "texture_index": 1,
    "size": 6.420785295439591,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "B91B9245-A53A-4622-B612-331AC6741C4F",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": 1093382436
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_9",
    "index": 9,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 5,
    "color": [
      175,
      219,
      245
    ],
    "texture_index": 1,
    "size": 4.828812221716932,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "8AB1B93C-435A-4953-B04E-82302A65E161",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": -1366568693
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_10",
    "index": 10,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 1,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 2,
    "size": 7.544809248658801,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "5855ABBD-319A-46F9-9182-16EDB77972D2",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_11",
    "index": 11,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 2,
    "color": [
      98,
      174,
      231
    ],
    "texture_index": 2,
    "size": 8.133967329591478,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "89D5C91E-6FC6-41D6-94E7-FA3BD6664A7F",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": 1630778393
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_12",
    "index": 12,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 5,
    "color": [
      175,
      219,
      245
    ],
    "texture_index": 2,
    "size": 10.896053075724545,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "D7E25E3F-4462-4E5B-9BC1-119678177FCF",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": -1366568693
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_13",
    "index": 13,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 2,
    "color": [
      98,
      174,
      231
    ],
    "texture_index": 2,
    "size": 8.203386638005775,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "9DA0092B-F846-4E5D-B66E-515709889CF2",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": 1630778393
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_14",
    "index": 14,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 1,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 2,
    "size": 8.487477261037972,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "265680AD-13B7-440B-8F33-3B940F80108E",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_15",
    "index": 15,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 7,
    "color": [
      98,
      174,
      231
    ],
    "texture_index": 0,
    "size": 11.0378706509212,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "51745C13-4198-4DFF-BC54-A1D3F299D2E9",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "54F4BBE7-D0F0-44AE-967A-74D3E830C1BC"
        },
        "color": {
          "type": "c",
          "value": 1630778393
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_16",
    "index": 16,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 2,
    "color": [
      98,
      174,
      231
    ],
    "texture_index": 3,
    "size": 5.928806889960901,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "3BC5C2E6-F9A4-411D-B9E0-945AE589F132",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A4BA980C-F28A-4B96-B9FF-98891244A608"
        },
        "color": {
          "type": "c",
          "value": 1630778393
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_17",
    "index": 17,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 4,
    "color": [
      46,
      132,
      206
    ],
    "texture_index": 1,
    "size": 9.67712514456279,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "1D718E08-BD93-4191-A272-C9978B25814A",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": 760328498
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_18",
    "index": 18,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 5,
    "color": [
      175,
      219,
      245
    ],
    "texture_index": 3,
    "size": 10.781870011172224,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "53E34BD9-C8A6-4B82-BF18-2367A2AB0355",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A4BA980C-F28A-4B96-B9FF-98891244A608"
        },
        "color": {
          "type": "c",
          "value": -1366568693
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_19",
    "index": 19,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 4,
    "color": [
      46,
      132,
      206
    ],
    "texture_index": 1,
    "size": 10.93843019992376,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "75DD5FE0-E0A7-4D17-BCC0-37BBFB8D919D",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": 760328498
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_20",
    "index": 20,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 5,
    "color": [
      175,
      219,
      245
    ],
    "texture_index": 1,
    "size": 6.733528998204349,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "2FDA1A85-3880-4BB0-821D-4D5DF659A8F0",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": -1366568693
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_21",
    "index": 21,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 3,
    "color": [
      66,
      150,
      220
    ],
    "texture_index": 1,
    "size": 4.11586540070577,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "517E1819-4118-40E0-B43A-8A2295FC6531",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": 1093382436
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_22",
    "index": 22,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 4,
    "color": [
      46,
      132,
      206
    ],
    "texture_index": 3,
    "size": 10.150525450258824,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "C43F00F9-61A3-46A8-93E3-AD38293C25A2",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A4BA980C-F28A-4B96-B9FF-98891244A608"
        },
        "color": {
          "type": "c",
          "value": 760328498
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_23",
    "index": 23,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 3,
    "color": [
      66,
      150,
      220
    ],
    "texture_index": 3,
    "size": 11.32477877787737,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "ED66FE59-B467-41D9-8E6C-81A7DC751DDD",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A4BA980C-F28A-4B96-B9FF-98891244A608"
        },
        "color": {
          "type": "c",
          "value": 1093382436
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_24",
    "index": 24,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 6,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 1,
    "size": 9.296831605370683,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "C3870AAB-4A59-456A-9027-1B0792080A66",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_25",
    "index": 25,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 6,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 1,
    "size": 10.358490579587995,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "E0F7EC71-1DDD-4123-9D82-7AA746DA51A7",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_26",
    "index": 26,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 5,
    "color": [
      175,
      219,
      245
    ],
    "texture_index": 4,
    "size": 11.213374961891294,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "F78416B3-4C81-4798-8E53-F18D5BA5938A",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "E30BDF75-7A06-462B-A66B-62A9EF9DA07A"
        },
        "color": {
          "type": "c",
          "value": -1366568693
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_27",
    "index": 27,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 3,
    "color": [
      66,
      150,
      220
    ],
    "texture_index": 2,
    "size": 10.378452882864059,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "35EC3E2F-69A5-42A7-BD63-3C341313CA17",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": 1093382436
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_28",
    "index": 28,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 6,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 4,
    "size": 5.329807374208011,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "587273BC-DB16-4B6E-AF99-E95D2CA2B215",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "E30BDF75-7A06-462B-A66B-62A9EF9DA07A"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_29",
    "index": 29,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 6,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 2,
    "size": 6.022946240003446,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "280B05F3-C4B0-4BB9-A589-10CB4B9740C3",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_30",
    "index": 30,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 0,
    "color": [
      175,
      219,
      245
    ],
    "texture_index": 1,
    "size": 7.466459165281503,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "2D54FABA-71E9-477E-88FC-F0749959ED43",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": -1366568693
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_31",
    "index": 31,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 4,
    "color": [
      46,
      132,
      206
    ],
    "texture_index": 2,
    "size": 10.220670268242342,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "6E44ECD1-514F-48E9-B7A2-4E9FA6F155CA",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": 760328498
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_32",
    "index": 32,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 0,
    "color": [
      175,
      219,
      245
    ],
    "texture_index": 2,
    "size": 5.544475314428274,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "72BD8CB0-58A0-42DE-91D0-21E4A75BE7F8",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": -1366568693
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_33",
    "index": 33,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 0,
    "color": [
      175,
      219,
      245
    ],
    "texture_index": 0,
    "size": 11.009420226317303,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "22A9CA65-95E5-418D-AF2E-878ED4EBB9F6",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "54F4BBE7-D0F0-44AE-967A-74D3E830C1BC"
        },
        "color": {
          "type": "c",
          "value": -1366568693
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_34",
    "index": 34,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 6,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 3,
    "size": 9.120075805923856,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "CBEF97D9-4D93-436D-85BA-E3B6BBF65B83",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A4BA980C-F28A-4B96-B9FF-98891244A608"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_35",
    "index": 35,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 4,
    "color": [
      46,
      132,
      206
    ],
    "texture_index": 3,
    "size": 6.454373143006775,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "0D6424FE-D731-4E7C-841F-429B49F0BFB8",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A4BA980C-F28A-4B96-B9FF-98891244A608"
        },
        "color": {
          "type": "c",
          "value": 760328498
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_36",
    "index": 36,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 0,
    "color": [
      175,
      219,
      245
    ],
    "texture_index": 1,
    "size": 7.482818297687999,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "244280F0-BA94-44C8-925E-5465A4D0F414",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": -1366568693
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_37",
    "index": 37,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 2,
    "color": [
      98,
      174,
      231
    ],
    "texture_index": 3,
    "size": 7.845660067530339,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "FD2DA47B-E8B1-4A43-9D96-D718B336052F",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A4BA980C-F28A-4B96-B9FF-98891244A608"
        },
        "color": {
          "type": "c",
          "value": 1630778393
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_38",
    "index": 38,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 4,
    "color": [
      46,
      132,
      206
    ],
    "texture_index": 0,
    "size": 6.717399903686729,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "CF3159A5-6201-484E-8A1B-15832D12B018",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "54F4BBE7-D0F0-44AE-967A-74D3E830C1BC"
        },
        "color": {
          "type": "c",
          "value": 760328498
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_39",
    "index": 39,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 6,
    "color": [
      147,
      205,
      241
    ],
    "texture_index": 1,
    "size": 9.950294821284313,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "09FAFE93-513F-4851-911A-B95CDBDA6E5F",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": -1834892529
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_40",
    "index": 40,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 4,
    "color": [
      46,
      132,
      206
    ],
    "texture_index": 2,
    "size": 4.399298491667535,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "05044B3D-7224-42CE-9226-6A6AB6EB03C3",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": 760328498
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_41",
    "index": 41,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 3,
    "color": [
      66,
      150,
      220
    ],
    "texture_index": 2,
    "size": 8.053066323390626,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "C27A5B71-1684-42F2-9927-5B0BA5D66FE6",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "1D1FA79A-B8EF-43A1-A01D-0DB2D107DEE8"
        },
        "color": {
          "type": "c",
          "value": 1093382436
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_42",
    "index": 42,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 3,
    "color": [
      66,
      150,
      220
    ],
    "texture_index": 3,
    "size": 6.3945423552836544,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "F7824B01-3F45-41F8-B500-E0BEF428FA3A",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A4BA980C-F28A-4B96-B9FF-98891244A608"
        },
        "color": {
          "type": "c",
          "value": 1093382436
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_43",
    "index": 43,
    "colorPalleteIndex": 21,
    "colorArrayIndex": 2,
    "color": [
      98,
      174,
      231
    ],
    "texture_index": 1,
    "size": 4.256044033889866,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "4D85D3D4-868B-4049-AC1D-7E05AA995E10",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "73EAF823-0BD5-47CC-B8CF-B7ADFD575EE3"
        },
        "color": {
          "type": "c",
          "value": 1630778393
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.67293979605824,
            88.85054408861602,
            167.44948968459113
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  }
]