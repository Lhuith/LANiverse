[
  {
    "name": "Astoriod_0",
    "index": 0,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 2,
    "color": [
      192,
      223,
      140
    ],
    "texture_index": 4,
    "size": 6.122263537384173,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "BB6AD0DE-9FDF-4063-83C4-F00D7DD7FBE6",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "8B918747-17CB-40CB-A743-843142BF1ECA"
        },
        "color": {
          "type": "c",
          "value": -1080120716
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_1",
    "index": 1,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 3,
    "color": [
      214,
      229,
      144
    ],
    "texture_index": 3,
    "size": 10.652642764566306,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "474A69F2-FC33-4937-A4CC-8DB465BD132D",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "ADA280B3-33BE-4418-8570-FC0DE227F707"
        },
        "color": {
          "type": "c",
          "value": -707881872
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_2",
    "index": 2,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 1,
    "color": [
      177,
      223,
      142
    ],
    "texture_index": 1,
    "size": 11.589374549265393,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "91F9BCB1-F353-4854-88C6-81C376C1273B",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A0EE43CC-4137-4065-B1D2-FBE50F19263A"
        },
        "color": {
          "type": "c",
          "value": -1332630414
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_3",
    "index": 3,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 2,
    "color": [
      192,
      223,
      140
    ],
    "texture_index": 3,
    "size": 7.508884872965334,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "F04DA45B-989B-4ABE-B520-66EDA788DD02",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "ADA280B3-33BE-4418-8570-FC0DE227F707"
        },
        "color": {
          "type": "c",
          "value": -1080120716
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_4",
    "index": 4,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 0,
    "color": [
      160,
      221,
      142
    ],
    "texture_index": 3,
    "size": 7.365806098918888,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "47208517-F4A9-4D14-B031-92C3F7B05E3B",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "ADA280B3-33BE-4418-8570-FC0DE227F707"
        },
        "color": {
          "type": "c",
          "value": -1615024526
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_5",
    "index": 5,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 4,
    "color": [
      234,
      232,
      142
    ],
    "texture_index": 3,
    "size": 6.379566093360667,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "2CBB79D1-E736-450E-903A-2BD9B66464C5",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "ADA280B3-33BE-4418-8570-FC0DE227F707"
        },
        "color": {
          "type": "c",
          "value": -370043534
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_6",
    "index": 6,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 0,
    "color": [
      160,
      221,
      142
    ],
    "texture_index": 3,
    "size": 4.844548959033824,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "9834FA06-406A-4CE0-997E-67ECF9E32236",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "ADA280B3-33BE-4418-8570-FC0DE227F707"
        },
        "color": {
          "type": "c",
          "value": -1615024526
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_7",
    "index": 7,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 2,
    "color": [
      192,
      223,
      140
    ],
    "texture_index": 1,
    "size": 7.308132193965031,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "6D8038FB-E02F-4A94-89B0-CA70CE93DAB7",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A0EE43CC-4137-4065-B1D2-FBE50F19263A"
        },
        "color": {
          "type": "c",
          "value": -1080120716
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_8",
    "index": 8,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 2,
    "color": [
      192,
      223,
      140
    ],
    "texture_index": 0,
    "size": 7.09117646934418,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "0F57DE09-E28C-4733-8582-4B41005F6A8D",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "84D5B74E-8EE5-43AD-96FA-052B68D2AE46"
        },
        "color": {
          "type": "c",
          "value": -1080120716
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_9",
    "index": 9,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 2,
    "color": [
      192,
      223,
      140
    ],
    "texture_index": 3,
    "size": 4.395225873970949,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "7CFF19D0-0B8D-43EB-8C8E-F5D6FF5358EA",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "ADA280B3-33BE-4418-8570-FC0DE227F707"
        },
        "color": {
          "type": "c",
          "value": -1080120716
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_10",
    "index": 10,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 2,
    "color": [
      192,
      223,
      140
    ],
    "texture_index": 0,
    "size": 5.02990408120421,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "A53B94D5-5CF6-4789-B1C9-41DC7CA21C12",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "84D5B74E-8EE5-43AD-96FA-052B68D2AE46"
        },
        "color": {
          "type": "c",
          "value": -1080120716
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_11",
    "index": 11,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 4,
    "color": [
      234,
      232,
      142
    ],
    "texture_index": 1,
    "size": 10.03441938709361,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "B1946E12-E549-4052-8643-E0B7306D08C7",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A0EE43CC-4137-4065-B1D2-FBE50F19263A"
        },
        "color": {
          "type": "c",
          "value": -370043534
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_12",
    "index": 12,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 4,
    "color": [
      234,
      232,
      142
    ],
    "texture_index": 1,
    "size": 5.067531810844391,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "7ACE3FF3-4CAA-46EC-8488-7CDE0CBF3E5C",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A0EE43CC-4137-4065-B1D2-FBE50F19263A"
        },
        "color": {
          "type": "c",
          "value": -370043534
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_13",
    "index": 13,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 1,
    "color": [
      177,
      223,
      142
    ],
    "texture_index": 3,
    "size": 6.825936092135036,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "DB49BD0B-557D-4682-A015-88A257F14046",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "ADA280B3-33BE-4418-8570-FC0DE227F707"
        },
        "color": {
          "type": "c",
          "value": -1332630414
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_14",
    "index": 14,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 2,
    "color": [
      192,
      223,
      140
    ],
    "texture_index": 3,
    "size": 4.559246004272154,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "A6482D6A-EB23-4BE1-B8F5-98857DF773E5",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "ADA280B3-33BE-4418-8570-FC0DE227F707"
        },
        "color": {
          "type": "c",
          "value": -1080120716
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_15",
    "index": 15,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 3,
    "color": [
      214,
      229,
      144
    ],
    "texture_index": 1,
    "size": 4.428066540019698,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "BDF916BD-7132-4339-9B54-6F6B4158156B",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A0EE43CC-4137-4065-B1D2-FBE50F19263A"
        },
        "color": {
          "type": "c",
          "value": -707881872
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_16",
    "index": 16,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 2,
    "color": [
      192,
      223,
      140
    ],
    "texture_index": 1,
    "size": 5.27517907126094,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "931F8518-81DC-486D-AD51-6B67C92371E2",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A0EE43CC-4137-4065-B1D2-FBE50F19263A"
        },
        "color": {
          "type": "c",
          "value": -1080120716
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_17",
    "index": 17,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 0,
    "color": [
      160,
      221,
      142
    ],
    "texture_index": 1,
    "size": 9.329671941250888,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "6EDAF185-522B-47CA-8036-DF6630CAE375",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A0EE43CC-4137-4065-B1D2-FBE50F19263A"
        },
        "color": {
          "type": "c",
          "value": -1615024526
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_18",
    "index": 18,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 3,
    "color": [
      214,
      229,
      144
    ],
    "texture_index": 3,
    "size": 5.380030074578286,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "4D653271-698A-426E-BE1A-B57F27DCE1F9",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "ADA280B3-33BE-4418-8570-FC0DE227F707"
        },
        "color": {
          "type": "c",
          "value": -707881872
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_19",
    "index": 19,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 3,
    "color": [
      214,
      229,
      144
    ],
    "texture_index": 1,
    "size": 11.861587825134905,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "02CEC262-C8FD-477D-AB9F-A68EEA61A5FA",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A0EE43CC-4137-4065-B1D2-FBE50F19263A"
        },
        "color": {
          "type": "c",
          "value": -707881872
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_20",
    "index": 20,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 0,
    "color": [
      160,
      221,
      142
    ],
    "texture_index": 4,
    "size": 8.59650927646184,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "3B136788-7D57-4221-8FAE-D593BBF07114",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "8B918747-17CB-40CB-A743-843142BF1ECA"
        },
        "color": {
          "type": "c",
          "value": -1615024526
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_21",
    "index": 21,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 1,
    "color": [
      177,
      223,
      142
    ],
    "texture_index": 3,
    "size": 10.179620351608058,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "C6D7695B-3B20-4938-82BA-982C305D2333",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "ADA280B3-33BE-4418-8570-FC0DE227F707"
        },
        "color": {
          "type": "c",
          "value": -1332630414
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_22",
    "index": 22,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 2,
    "color": [
      192,
      223,
      140
    ],
    "texture_index": 2,
    "size": 11.345133161235793,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "09ABA569-1A88-4BEF-915C-2C1CD73FB301",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "0CFD6EDF-96FE-4922-A9EF-96F16B7CE4FC"
        },
        "color": {
          "type": "c",
          "value": -1080120716
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_23",
    "index": 23,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 3,
    "color": [
      214,
      229,
      144
    ],
    "texture_index": 0,
    "size": 11.523622500469417,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "935DC08D-01D2-40B8-8405-AD4BC44737B4",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "84D5B74E-8EE5-43AD-96FA-052B68D2AE46"
        },
        "color": {
          "type": "c",
          "value": -707881872
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_24",
    "index": 24,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 3,
    "color": [
      214,
      229,
      144
    ],
    "texture_index": 3,
    "size": 4.3476940314565695,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "F208D450-7158-4174-BA97-0A3EE402FAD3",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "ADA280B3-33BE-4418-8570-FC0DE227F707"
        },
        "color": {
          "type": "c",
          "value": -707881872
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_25",
    "index": 25,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 2,
    "color": [
      192,
      223,
      140
    ],
    "texture_index": 3,
    "size": 4.132918875539508,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "FEEA7772-EF09-4DBB-89BB-8612DC0875C9",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "ADA280B3-33BE-4418-8570-FC0DE227F707"
        },
        "color": {
          "type": "c",
          "value": -1080120716
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_26",
    "index": 26,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 0,
    "color": [
      160,
      221,
      142
    ],
    "texture_index": 3,
    "size": 10.694309070135947,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "3D3D74C7-03A3-4540-AB11-22A07A33C89B",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "ADA280B3-33BE-4418-8570-FC0DE227F707"
        },
        "color": {
          "type": "c",
          "value": -1615024526
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_27",
    "index": 27,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 2,
    "color": [
      192,
      223,
      140
    ],
    "texture_index": 3,
    "size": 5.357431911073602,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "D8DAAE75-28C4-45F2-84F2-C64F720FD287",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "ADA280B3-33BE-4418-8570-FC0DE227F707"
        },
        "color": {
          "type": "c",
          "value": -1080120716
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_28",
    "index": 28,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 2,
    "color": [
      192,
      223,
      140
    ],
    "texture_index": 0,
    "size": 11.179567861681427,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "084A2972-C3AF-4B89-B026-AD336D47AF54",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "84D5B74E-8EE5-43AD-96FA-052B68D2AE46"
        },
        "color": {
          "type": "c",
          "value": -1080120716
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_29",
    "index": 29,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 1,
    "color": [
      177,
      223,
      142
    ],
    "texture_index": 3,
    "size": 5.525356687244985,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "7C5220DF-C79D-4BA0-A693-3E844A58DEAB",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "ADA280B3-33BE-4418-8570-FC0DE227F707"
        },
        "color": {
          "type": "c",
          "value": -1332630414
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_30",
    "index": 30,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 1,
    "color": [
      177,
      223,
      142
    ],
    "texture_index": 4,
    "size": 10.269500387249742,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "4392CEC1-7C47-4326-82E3-2C31F22B140A",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "8B918747-17CB-40CB-A743-843142BF1ECA"
        },
        "color": {
          "type": "c",
          "value": -1332630414
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_31",
    "index": 31,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 2,
    "color": [
      192,
      223,
      140
    ],
    "texture_index": 1,
    "size": 7.532833761993608,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "6D5FDAE1-8937-4F78-AA41-C06FC8C516D8",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A0EE43CC-4137-4065-B1D2-FBE50F19263A"
        },
        "color": {
          "type": "c",
          "value": -1080120716
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_32",
    "index": 32,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 3,
    "color": [
      214,
      229,
      144
    ],
    "texture_index": 4,
    "size": 9.412963455894829,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "0E422BF4-8850-4266-8848-A6D1D4F06BE5",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "8B918747-17CB-40CB-A743-843142BF1ECA"
        },
        "color": {
          "type": "c",
          "value": -707881872
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_33",
    "index": 33,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 0,
    "color": [
      160,
      221,
      142
    ],
    "texture_index": 2,
    "size": 11.455074884908932,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "A95DF31B-503E-41B0-8EC7-BF9179484727",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "0CFD6EDF-96FE-4922-A9EF-96F16B7CE4FC"
        },
        "color": {
          "type": "c",
          "value": -1615024526
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_34",
    "index": 34,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 4,
    "color": [
      234,
      232,
      142
    ],
    "texture_index": 3,
    "size": 10.93133905600935,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "6D92E5EF-9300-47BE-BC75-067B260A8CA7",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "ADA280B3-33BE-4418-8570-FC0DE227F707"
        },
        "color": {
          "type": "c",
          "value": -370043534
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_35",
    "index": 35,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 1,
    "color": [
      177,
      223,
      142
    ],
    "texture_index": 2,
    "size": 7.804647292107369,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "7C8F6B75-7ED4-48FE-9FD6-021E43D218C6",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "0CFD6EDF-96FE-4922-A9EF-96F16B7CE4FC"
        },
        "color": {
          "type": "c",
          "value": -1332630414
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_36",
    "index": 36,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 1,
    "color": [
      177,
      223,
      142
    ],
    "texture_index": 1,
    "size": 9.61967915639905,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "5DCD9EAB-4B41-483E-A640-42EA91229000",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A0EE43CC-4137-4065-B1D2-FBE50F19263A"
        },
        "color": {
          "type": "c",
          "value": -1332630414
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_37",
    "index": 37,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 1,
    "color": [
      177,
      223,
      142
    ],
    "texture_index": 3,
    "size": 8.513766627927584,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "0C01D8E4-26AC-4F4D-90B9-D1BB5EC390C3",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "ADA280B3-33BE-4418-8570-FC0DE227F707"
        },
        "color": {
          "type": "c",
          "value": -1332630414
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_38",
    "index": 38,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 2,
    "color": [
      192,
      223,
      140
    ],
    "texture_index": 1,
    "size": 7.518995823785323,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "4CCFB060-FDFF-4DFC-A23A-8366606A8779",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "A0EE43CC-4137-4065-B1D2-FBE50F19263A"
        },
        "color": {
          "type": "c",
          "value": -1080120716
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_39",
    "index": 39,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 1,
    "color": [
      177,
      223,
      142
    ],
    "texture_index": 3,
    "size": 7.056344722443239,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "0C3B0909-9A89-4DE4-94DE-DE2236126974",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "ADA280B3-33BE-4418-8570-FC0DE227F707"
        },
        "color": {
          "type": "c",
          "value": -1332630414
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_40",
    "index": 40,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 3,
    "color": [
      214,
      229,
      144
    ],
    "texture_index": 2,
    "size": 6.610342871160459,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "59979101-0A8F-4DAF-A353-0EA0E36D0AC2",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "0CFD6EDF-96FE-4922-A9EF-96F16B7CE4FC"
        },
        "color": {
          "type": "c",
          "value": -707881872
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_41",
    "index": 41,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 4,
    "color": [
      234,
      232,
      142
    ],
    "texture_index": 3,
    "size": 6.230335216965191,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "9AB99D5B-7B4F-42AE-886C-A17039F137E2",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "ADA280B3-33BE-4418-8570-FC0DE227F707"
        },
        "color": {
          "type": "c",
          "value": -370043534
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_42",
    "index": 42,
    "colorPalleteIndex": 66,
    "colorArrayIndex": 2,
    "color": [
      192,
      223,
      140
    ],
    "texture_index": 2,
    "size": 9.357424186160022,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "3C3CD0D5-CF3E-4CE7-AC81-B62BBCA01EA4",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "0CFD6EDF-96FE-4922-A9EF-96F16B7CE4FC"
        },
        "color": {
          "type": "c",
          "value": -1080120716
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -462.6753502382769,
            88.85021474958465,
            167.4430040964402
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  }
]