[
  {
    "name": "Astoriod_0",
    "index": 0,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 3,
    "color": [
      210,
      115,
      139
    ],
    "texture_index": 3,
    "size": 8.689891039137764,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "A7D14DF3-2584-4F25-AC37-C4786E761E2B",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "5D1D45E7-9616-4897-B9C6-5ACF29514F5C"
        },
        "color": {
          "type": "c",
          "value": -782497931
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_1",
    "index": 1,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 3,
    "color": [
      210,
      115,
      139
    ],
    "texture_index": 2,
    "size": 8.644336586714239,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "E91619CC-6FA5-404A-91CB-0B8BF22C44BB",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "46502CC1-A852-4FD0-9343-3064593F9AFF"
        },
        "color": {
          "type": "c",
          "value": -782497931
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_2",
    "index": 2,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 2,
    "color": [
      189,
      89,
      122
    ],
    "texture_index": 0,
    "size": 10.387459018756266,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "205C2477-AED7-4FD4-A82F-7CF9E695099E",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "063A6774-A7B9-45CF-A394-6AD2AFF350CD"
        },
        "color": {
          "type": "c",
          "value": -1139024250
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_3",
    "index": 3,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 1,
    "color": [
      248,
      131,
      142
    ],
    "texture_index": 1,
    "size": 5.174405748381499,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "A7BCC5A3-85F5-4F04-8C50-373B3C910A97",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9ACA604D-B2D8-43E5-A8AB-62010AD6DE18"
        },
        "color": {
          "type": "c",
          "value": -141889422
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_4",
    "index": 4,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 4,
    "color": [
      170,
      170,
      170
    ],
    "texture_index": 4,
    "size": 11.681465592942393,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "426D339C-FFB8-403E-9B77-35512E86B83D",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "3A4B68AC-05A8-4749-A780-14CEC17D8B1F"
        },
        "color": {
          "type": "c",
          "value": -1442840746
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_5",
    "index": 5,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 3,
    "color": [
      210,
      115,
      139
    ],
    "texture_index": 1,
    "size": 10.528549928480068,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "AD7E1BF2-E51C-4990-B202-6B3FCAA4BF4C",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9ACA604D-B2D8-43E5-A8AB-62010AD6DE18"
        },
        "color": {
          "type": "c",
          "value": -782497931
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_6",
    "index": 6,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 2,
    "color": [
      189,
      89,
      122
    ],
    "texture_index": 4,
    "size": 5.174377843141112,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "A0534C1E-61E5-414B-8367-030D272FE955",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "3A4B68AC-05A8-4749-A780-14CEC17D8B1F"
        },
        "color": {
          "type": "c",
          "value": -1139024250
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_7",
    "index": 7,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 3,
    "color": [
      210,
      115,
      139
    ],
    "texture_index": 2,
    "size": 9.897803603634703,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "5B83C6A9-5DCA-4012-9F61-D018A3E98135",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "46502CC1-A852-4FD0-9343-3064593F9AFF"
        },
        "color": {
          "type": "c",
          "value": -782497931
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_8",
    "index": 8,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 1,
    "color": [
      248,
      131,
      142
    ],
    "texture_index": 0,
    "size": 8.549166024822567,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "E687CC11-6EEC-4ADF-BF11-77AFB091BC39",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "063A6774-A7B9-45CF-A394-6AD2AFF350CD"
        },
        "color": {
          "type": "c",
          "value": -141889422
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_9",
    "index": 9,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 3,
    "color": [
      210,
      115,
      139
    ],
    "texture_index": 1,
    "size": 4.374716767606472,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "F9A35C7C-840B-4415-BCE4-BE3A57618BF5",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9ACA604D-B2D8-43E5-A8AB-62010AD6DE18"
        },
        "color": {
          "type": "c",
          "value": -782497931
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_10",
    "index": 10,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 3,
    "color": [
      210,
      115,
      139
    ],
    "texture_index": 4,
    "size": 8.271427233684502,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "3F0BE077-2FCC-48A1-A89F-D5B521B9AE9D",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "3A4B68AC-05A8-4749-A780-14CEC17D8B1F"
        },
        "color": {
          "type": "c",
          "value": -782497931
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_11",
    "index": 11,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 4,
    "color": [
      170,
      170,
      170
    ],
    "texture_index": 2,
    "size": 6.779134609303368,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "3033F80F-7DE8-44EC-910D-03733F7D8EA1",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "46502CC1-A852-4FD0-9343-3064593F9AFF"
        },
        "color": {
          "type": "c",
          "value": -1442840746
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_12",
    "index": 12,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 1,
    "color": [
      248,
      131,
      142
    ],
    "texture_index": 1,
    "size": 9.028120020963149,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "C1171112-E039-4524-B92E-19D1DF5D90A1",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9ACA604D-B2D8-43E5-A8AB-62010AD6DE18"
        },
        "color": {
          "type": "c",
          "value": -141889422
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_13",
    "index": 13,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 4,
    "color": [
      170,
      170,
      170
    ],
    "texture_index": 0,
    "size": 8.342566425924021,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "B09AE989-1441-4E34-B4DD-A4FC41A2F3A8",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "063A6774-A7B9-45CF-A394-6AD2AFF350CD"
        },
        "color": {
          "type": "c",
          "value": -1442840746
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_14",
    "index": 14,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 2,
    "color": [
      189,
      89,
      122
    ],
    "texture_index": 1,
    "size": 11.166897798902147,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "7FCF5E86-A8D3-42F0-BC5B-586832C6638A",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9ACA604D-B2D8-43E5-A8AB-62010AD6DE18"
        },
        "color": {
          "type": "c",
          "value": -1139024250
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_15",
    "index": 15,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 3,
    "color": [
      210,
      115,
      139
    ],
    "texture_index": 4,
    "size": 5.5596426424691785,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "AFD4F867-10DA-4ED2-B01F-0D5030FA2DE7",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "3A4B68AC-05A8-4749-A780-14CEC17D8B1F"
        },
        "color": {
          "type": "c",
          "value": -782497931
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_16",
    "index": 16,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 2,
    "color": [
      189,
      89,
      122
    ],
    "texture_index": 3,
    "size": 6.2646742610610975,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "FC48095C-D237-44EB-B283-C76D780656DC",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "5D1D45E7-9616-4897-B9C6-5ACF29514F5C"
        },
        "color": {
          "type": "c",
          "value": -1139024250
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_17",
    "index": 17,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 3,
    "color": [
      210,
      115,
      139
    ],
    "texture_index": 3,
    "size": 6.7033267040369235,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "4E9FD3CE-1AB4-4338-A2FC-109F93D41E94",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "5D1D45E7-9616-4897-B9C6-5ACF29514F5C"
        },
        "color": {
          "type": "c",
          "value": -782497931
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_18",
    "index": 18,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 2,
    "color": [
      189,
      89,
      122
    ],
    "texture_index": 2,
    "size": 11.839842450567653,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "7D2D3F2C-A64F-46E4-A2A5-0D68B9C8B8DB",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "46502CC1-A852-4FD0-9343-3064593F9AFF"
        },
        "color": {
          "type": "c",
          "value": -1139024250
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_19",
    "index": 19,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 0,
    "color": [
      214,
      101,
      116
    ],
    "texture_index": 1,
    "size": 7.438787104173253,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "3B688CBA-39B6-481A-891B-304BF8D4EDC7",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9ACA604D-B2D8-43E5-A8AB-62010AD6DE18"
        },
        "color": {
          "type": "c",
          "value": -716248948
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_20",
    "index": 20,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 2,
    "color": [
      189,
      89,
      122
    ],
    "texture_index": 1,
    "size": 10.000122677633351,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "6BE8910A-BB1E-4B2D-B846-B781ACD81BFE",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9ACA604D-B2D8-43E5-A8AB-62010AD6DE18"
        },
        "color": {
          "type": "c",
          "value": -1139024250
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_21",
    "index": 21,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 2,
    "color": [
      189,
      89,
      122
    ],
    "texture_index": 2,
    "size": 6.761144428050031,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "E6776F02-355E-415E-BBFF-AFC4E7533154",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "46502CC1-A852-4FD0-9343-3064593F9AFF"
        },
        "color": {
          "type": "c",
          "value": -1139024250
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_22",
    "index": 22,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 1,
    "color": [
      248,
      131,
      142
    ],
    "texture_index": 2,
    "size": 7.0393498627286455,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "8D41EE7C-E77E-47BF-BB27-753E381ED0DC",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "46502CC1-A852-4FD0-9343-3064593F9AFF"
        },
        "color": {
          "type": "c",
          "value": -141889422
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_23",
    "index": 23,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 0,
    "color": [
      214,
      101,
      116
    ],
    "texture_index": 2,
    "size": 9.152742784516697,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "DB30AE35-DB73-4211-BEF8-D17C0A88566D",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "46502CC1-A852-4FD0-9343-3064593F9AFF"
        },
        "color": {
          "type": "c",
          "value": -716248948
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_24",
    "index": 24,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 1,
    "color": [
      248,
      131,
      142
    ],
    "texture_index": 0,
    "size": 5.3073083610058,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "E6B31749-3DBC-4FD0-A7B8-0EB50A0ABEE8",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "063A6774-A7B9-45CF-A394-6AD2AFF350CD"
        },
        "color": {
          "type": "c",
          "value": -141889422
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_25",
    "index": 25,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 1,
    "color": [
      248,
      131,
      142
    ],
    "texture_index": 3,
    "size": 5.3214614488380345,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "6E4311CA-161F-4B26-A3DE-D1D172A58866",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "5D1D45E7-9616-4897-B9C6-5ACF29514F5C"
        },
        "color": {
          "type": "c",
          "value": -141889422
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_26",
    "index": 26,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 2,
    "color": [
      189,
      89,
      122
    ],
    "texture_index": 4,
    "size": 9.42956805622531,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "762C3E45-337D-4F9D-821A-94561CEC9CE9",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "3A4B68AC-05A8-4749-A780-14CEC17D8B1F"
        },
        "color": {
          "type": "c",
          "value": -1139024250
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_27",
    "index": 27,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 2,
    "color": [
      189,
      89,
      122
    ],
    "texture_index": 4,
    "size": 10.172322206457562,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "097E131B-FF78-4162-BFA7-5C23BA492D78",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "3A4B68AC-05A8-4749-A780-14CEC17D8B1F"
        },
        "color": {
          "type": "c",
          "value": -1139024250
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_28",
    "index": 28,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 3,
    "color": [
      210,
      115,
      139
    ],
    "texture_index": 2,
    "size": 6.203502491194952,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "6B727D85-60E4-4180-B35F-2D4131B8D79E",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "46502CC1-A852-4FD0-9343-3064593F9AFF"
        },
        "color": {
          "type": "c",
          "value": -782497931
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_29",
    "index": 29,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 1,
    "color": [
      248,
      131,
      142
    ],
    "texture_index": 1,
    "size": 7.430519951230897,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "717D333F-7C81-46C8-A585-C0B718E66DDC",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9ACA604D-B2D8-43E5-A8AB-62010AD6DE18"
        },
        "color": {
          "type": "c",
          "value": -141889422
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_30",
    "index": 30,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 3,
    "color": [
      210,
      115,
      139
    ],
    "texture_index": 0,
    "size": 6.947064220878376,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "DAD2CD28-73B8-4496-8D76-EB35E9FA7E0E",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "063A6774-A7B9-45CF-A394-6AD2AFF350CD"
        },
        "color": {
          "type": "c",
          "value": -782497931
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_31",
    "index": 31,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 1,
    "color": [
      248,
      131,
      142
    ],
    "texture_index": 2,
    "size": 8.383377715848317,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "4CB7327E-6C4A-4909-BB9B-ACC6A04A390A",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "46502CC1-A852-4FD0-9343-3064593F9AFF"
        },
        "color": {
          "type": "c",
          "value": -141889422
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_32",
    "index": 32,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 4,
    "color": [
      170,
      170,
      170
    ],
    "texture_index": 2,
    "size": 10.389489748845651,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "21EB40F6-F332-487D-8F94-077A75009DC0",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "46502CC1-A852-4FD0-9343-3064593F9AFF"
        },
        "color": {
          "type": "c",
          "value": -1442840746
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_33",
    "index": 33,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 1,
    "color": [
      248,
      131,
      142
    ],
    "texture_index": 0,
    "size": 8.726310319895026,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "5DA0138D-D322-40B8-8C73-90CF5070D535",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "063A6774-A7B9-45CF-A394-6AD2AFF350CD"
        },
        "color": {
          "type": "c",
          "value": -141889422
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_34",
    "index": 34,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 4,
    "color": [
      170,
      170,
      170
    ],
    "texture_index": 1,
    "size": 5.761748381394762,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "3A09994D-1AF1-45EE-A52B-7796C5C752CC",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9ACA604D-B2D8-43E5-A8AB-62010AD6DE18"
        },
        "color": {
          "type": "c",
          "value": -1442840746
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_35",
    "index": 35,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 0,
    "color": [
      214,
      101,
      116
    ],
    "texture_index": 3,
    "size": 7.752926140439509,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "7F75A931-A995-42FE-8BDF-40B25C90C0E4",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "5D1D45E7-9616-4897-B9C6-5ACF29514F5C"
        },
        "color": {
          "type": "c",
          "value": -716248948
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_36",
    "index": 36,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 3,
    "color": [
      210,
      115,
      139
    ],
    "texture_index": 2,
    "size": 9.288354418329055,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "C2A27098-3C2F-4C64-9EDD-5F3A8295499A",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "46502CC1-A852-4FD0-9343-3064593F9AFF"
        },
        "color": {
          "type": "c",
          "value": -782497931
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_37",
    "index": 37,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 3,
    "color": [
      210,
      115,
      139
    ],
    "texture_index": 2,
    "size": 11.077797656026197,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "C50FB0ED-4E4F-4051-9F23-E8558EF2E8C1",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "46502CC1-A852-4FD0-9343-3064593F9AFF"
        },
        "color": {
          "type": "c",
          "value": -782497931
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_38",
    "index": 38,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 2,
    "color": [
      189,
      89,
      122
    ],
    "texture_index": 1,
    "size": 9.231158436292109,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "E6A15428-48B2-4ACA-A5D7-C05CC7D2D917",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9ACA604D-B2D8-43E5-A8AB-62010AD6DE18"
        },
        "color": {
          "type": "c",
          "value": -1139024250
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_39",
    "index": 39,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 1,
    "color": [
      248,
      131,
      142
    ],
    "texture_index": 3,
    "size": 8.375606282292647,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "320F7C2E-8FFE-4C15-89ED-82C98A2BCC6F",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "5D1D45E7-9616-4897-B9C6-5ACF29514F5C"
        },
        "color": {
          "type": "c",
          "value": -141889422
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_40",
    "index": 40,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 4,
    "color": [
      170,
      170,
      170
    ],
    "texture_index": 2,
    "size": 7.6021923913002425,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "3E7B2FF7-6C67-44C8-8FAC-9F790A1EBDB5",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "46502CC1-A852-4FD0-9343-3064593F9AFF"
        },
        "color": {
          "type": "c",
          "value": -1442840746
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_41",
    "index": 41,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 2,
    "color": [
      189,
      89,
      122
    ],
    "texture_index": 1,
    "size": 9.831502174911225,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "F0D5C649-97F8-4EDE-9C67-2A49051D9BE8",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9ACA604D-B2D8-43E5-A8AB-62010AD6DE18"
        },
        "color": {
          "type": "c",
          "value": -1139024250
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_42",
    "index": 42,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 1,
    "color": [
      248,
      131,
      142
    ],
    "texture_index": 0,
    "size": 8.714298325468407,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "E63663B0-8540-4CCF-8905-51C05B0AFAC1",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "063A6774-A7B9-45CF-A394-6AD2AFF350CD"
        },
        "color": {
          "type": "c",
          "value": -141889422
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_43",
    "index": 43,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 1,
    "color": [
      248,
      131,
      142
    ],
    "texture_index": 0,
    "size": 10.225977926070529,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "8327DE0B-8B95-4204-BDCB-AA5841170BF4",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "063A6774-A7B9-45CF-A394-6AD2AFF350CD"
        },
        "color": {
          "type": "c",
          "value": -141889422
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_44",
    "index": 44,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 4,
    "color": [
      170,
      170,
      170
    ],
    "texture_index": 4,
    "size": 7.138416637034002,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "41BA7F9A-AC26-4405-835A-EC2E50AE5AE5",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "3A4B68AC-05A8-4749-A780-14CEC17D8B1F"
        },
        "color": {
          "type": "c",
          "value": -1442840746
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_45",
    "index": 45,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 1,
    "color": [
      248,
      131,
      142
    ],
    "texture_index": 1,
    "size": 7.42348875055141,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "FE6DB22A-AB82-4F26-AAFA-11E1D0ED0C99",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "9ACA604D-B2D8-43E5-A8AB-62010AD6DE18"
        },
        "color": {
          "type": "c",
          "value": -141889422
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_46",
    "index": 46,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 4,
    "color": [
      170,
      170,
      170
    ],
    "texture_index": 3,
    "size": 8.049746761257245,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "A6967114-CDA0-4C91-8CC6-44119A79ABB7",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "5D1D45E7-9616-4897-B9C6-5ACF29514F5C"
        },
        "color": {
          "type": "c",
          "value": -1442840746
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  },
  {
    "name": "Astoriod_47",
    "index": 47,
    "colorPalleteIndex": 4,
    "colorArrayIndex": 1,
    "color": [
      248,
      131,
      142
    ],
    "texture_index": 2,
    "size": 8.151468506117531,
    "astomat": {
      "metadata": {
        "version": 4.5,
        "type": "Material",
        "generator": "Material.toJSON"
      },
      "uuid": "5D4C410A-73CB-4139-99E6-DD82E6777F50",
      "type": "ShaderMaterial",
      "depthFunc": 3,
      "depthTest": true,
      "depthWrite": true,
      "uniforms": {
        "ambientLightColor": {
          "value": []
        },
        "directionalLights": {
          "value": []
        },
        "directionalShadowMap": {
          "value": []
        },
        "directionalShadowMatrix": {
          "value": []
        },
        "spotLights": {
          "value": []
        },
        "spotShadowMap": {
          "value": []
        },
        "spotShadowMatrix": {
          "value": []
        },
        "pointLights": {
          "value": []
        },
        "pointShadowMap": {
          "value": []
        },
        "pointShadowMatrix": {
          "value": []
        },
        "hemisphereLights": {
          "value": []
        },
        "rectAreaLights": {
          "value": []
        },
        "texture": {
          "type": "t",
          "value": "46502CC1-A852-4FD0-9343-3064593F9AFF"
        },
        "color": {
          "type": "c",
          "value": -141889422
        },
        "lightpos": {
          "type": "v3",
          "value": [
            -461.0594084152264,
            89.06460919992213,
            171.7315268081742
          ]
        }
      },
      "vertexShader": "\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 lightdir;\r\n \t\tvarying vec3 eyenorm;\r\n \t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\t\tvarying vec3 vViewPosition;\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\r\n\t\tvoid main() \r\n\t\t{\t\r\n\t\t\tvUv = uv;\r\n\t\t\t\r\n\t\t\tvec3 transformed = vec3( position );\r\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\r\n\t\t\teyepos = modelViewMatrix * vec4 (position, 1.0);\r\n\t\t\tvec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);\r\n\r\n\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\t\t\tvecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;\r\n\t\t\t\r\n\t\t\tvec4 tmp = modelViewMatrix * vec4 (lightpos, 1.0);\r\n\t\t\tlightdir = lighteye.xyz - eyepos.xyz;\r\n\t\t\teyenorm = normalMatrix * normal;\r\n\t\t\t\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n\t\t\t // store the world position as varying for lighting\r\n    \t\tvWorldPosition = worldPosition.xyz;\r\n\t\t\tvViewPosition = - mvPosition.xyz;\r\n\t\t\t\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\r\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t\t\t}\r\n\r\n\t\t}",
      "fragmentShader": "\r\n\t\tvarying vec3 lightdir;\r\n\t\tvarying vec3 eyenorm;\r\n\t\tuniform sampler2D texture;\t\t\r\n\t\tuniform vec3 color; \t\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform vec3 lightpos;\r\n\t\tvarying vec4 eyepos;\r\n\r\n\t\tvarying vec3 vecNormal;\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t\t//Although looks random as fuck, its being parsed//recplaced with Shadow.glsl, \r\n\t\t//refer to mains callback async nested bumb \r\n\t\t\r\n\t\t#define SHADOWMAP_TYPE_PCF_SOFT\r\n\t\t#define SHADOWMAP_TYPE_PCF\r\n\r\n\t\tvec3 packNormalToRGB( const in vec3 normal ) {\r\n\t\treturn normalize( normal ) * 0.5 + 0.5;\r\n\t\t}\r\n\r\n\t\tvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\t\treturn 1.0 - 2.0 * rgb.xyz;\r\n\t\t}\r\n\r\n\t\tconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\n\t\tconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\n\t\tconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\n\t\tconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\t\tconst float ShiftRight8 = 1. / 256.;\r\n\r\n\t\tvec4 packDepthToRGBA( const in float v ) {\r\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\t\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\t\treturn r * PackUpscale;\r\n\t\t}\r\n\r\n\t\tfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\t\treturn dot( v, UnpackFactors );\r\n\t\t}\r\n\r\n\t\t// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\n\t\tfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn ( viewZ + near ) / ( near - far );\r\n\t\t}\r\n\t\tfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\t\treturn linearClipZ * ( near - far ) - near;\r\n\t\t}\r\n\r\n\t\tfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\t\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n\t\t}\r\n\t\tfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\t\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) \r\n\t\t{\r\n\r\n\t\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\t\tfloat a = mix( lb, lt, f.y );\r\n\t\t\tfloat b = mix( rb, rt, f.y );\r\n\t\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\t\treturn c;\r\n\r\n\t\t}\r\n\r\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\t\tfloat shadow = 1.0;\r\n\r\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\t\tshadow = (\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shadow;\r\n\t\t}\r\n\t\t//--------------------------------------------------------------------\r\n\t\t//-------------------------------------------------------------------\r\n\r\n\r\n\t\t\t#if NUM_DIR_LIGHTS > 0\r\n\t\tstruct DirectionalLight \r\n\t\t{\r\n\t\t\tvec3 direction;\r\n\t\t\tvec3 color;\r\n\t\t\tint shadow;\r\n\t\t\tfloat shadowBias;\r\n\t\t\tfloat shadowRadius;\r\n\t\t\tvec2 shadowMapSize;\r\n\t\t};\r\n\r\n\t\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t\t#endif\r\n\r\n\r\n\t\tvoid main()\r\n\t\t{\r\n\r\n\t\t\tvec3 lightDirection = normalize(directionalLights[0].direction - vWorldPosition);\r\n\r\n\t\t\tvec3 sumDirLights = clamp( dot( directionalLights[0].direction, \r\n\t\t\tvecNormal ), 0.0, .75 ) * directionalLights[0].color  * 1.0;\r\n\r\n\t\t\tfloat shadowValue = getShadow(directionalShadowMap[ 0 ], directionalLights[0].shadowMapSize, \r\n\t\t\tdirectionalLights[0].shadowBias, directionalLights[0].shadowRadius, vDirectionalShadowCoord[0] );\r\n\r\n\r\n\t\t\tvec4 tex = texture2D(texture, vUv);\r\n\t\t\tif (tex.a != 1.0) \r\n\t\t\tdiscard;\r\n\r\n\t\t\tgl_FragColor =  (tex * \r\n\t\t\tvec4(color.r/255.0, color.g/255.0, color.b/255.0, 1.0)) * \r\n\t\t\t shadowValue;\r\n\t\t}"
    }
  }
]